# 1st solution
# O(mn^2) time | O(n) space
class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        n = len(graph)
        g = [[] for _ in range(n)]
        for i in range(n):
            for j in range(i + 1, n):
                if graph[i][j] == 1:
                    g[i].append(j)
                    g[j].append(i)

        def getCounts(level):
            val = len(level)
            visited = [False for _ in range(n)]
            for node in level:
                visited[node] = True
            while level:
                newLevel = []
                for node in level:
                    for neig in g[node]:
                        if visited[neig] or not valid[neig]:
                            continue
                        newLevel.append(neig)
                        visited[neig] = True
                        val += 1
                level = newLevel
            return val
        
        valid = [True for _ in range(n)]
        ans = None
        count = n + 1
        for i in range(len(initial)):
            node = initial[i]
            valid[node] = False
            v = getCounts(initial[:i] + initial[i+1:])
            if v < count:
                ans = node
            elif v == count and node < ans:
                ans = node
            count = min(count, v)
            valid[node] = True
        return ans

# 2nd solution
# O(n^2) time | O(n) space
class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        st = set(initial)
        vis = [False] * len(graph)
        def dfs(x: int) -> None:
            vis[x] = True
            nonlocal node_id, size
            size += 1
            for y, conn in enumerate(graph[x]):
                if conn == 0:
                    continue
                if y in st:
                    # 按照 924 题的状态机更新 node_id
                    # 注意避免重复统计，例如上图中的 0 有两条不同路径可以遇到 1
                    if node_id != -2 and node_id != y:
                        node_id = y if node_id == -1 else -2
                elif not vis[y]:
                    dfs(y)

        cnt = Counter()
        for i, seen in enumerate(vis):
            if seen or i in st:
                continue
            node_id = -1
            size = 0
            dfs(i)
            if node_id >= 0:  # 只找到一个在 initial 中的节点
                # 删除节点 node_id 可以让 size 个点不被感染
                cnt[node_id] += size

        # size 取反计算最大值，相同最大值取 node_id 最小值
        return min((-size, node_id) for node_id, size in cnt.items())[1] if cnt else min(initial)
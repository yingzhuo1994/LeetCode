# 1st solution
# O(n^2) time | O(n) space
class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        n = len(graph)
        DS = DisjointSet(n)
        for i in range(n):
            for j in range(i + 1, n):
                if graph[i][j] == 1:
                    DS.merge(i, j)
        uniqueInitials = {}
        for x in initial:
            p = DS.getParent(x)
            if p not in uniqueInitials:
                uniqueInitials[p] = []
            uniqueInitials[p].append(x)

        maxSize = 0
        ans = None
        for p, v in uniqueInitials.items():
            if len(v) == 1:
                if DS.getSize(p) > maxSize:
                    maxSize = DS.getSize(p)
                    ans = v[0]
                elif DS.getSize(p) == maxSize:
                    ans = min(ans, v[0])
        
        if ans is not None:
            return ans
        
        return min(initial)
        

class DisjointSet:
    def __init__(self, n):
        self.parents = [i for i in range(n)]
        self.size = [1 for _ in range(n)]
    
    def merge(self, a, b):
        pa, pb = self.getParent(a), self.getParent(b)
        if pa == pb:
            return
        if self.size[pb] > self.size[pa]:
            a, b = b, a
            pa, pb = pb, pa
        self.parents[pb] = pa
        self.size[pa] += self.size[pb]
        
    def getParent(self, x):
        if x != self.parents[x]:
            self.parents[x] = self.getParent(self.parents[x])
        return self.parents[x]
    
    def getSize(self, x):
        return self.size[x]

# 2nd solution
# O(n^2) time | O(n) space
class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        st = set(initial)
        vis = [False] * len(graph)
        def dfs(x: int) -> None:
            vis[x] = True
            nonlocal node_id, size
            size += 1
            # 按照状态机更新 node_id
            if node_id != -2 and x in st:
                node_id = x if node_id == -1 else -2
            for y, conn in enumerate(graph[x]):
                if conn and not vis[y]:
                    dfs(y)

        ans = -1
        max_size = 0
        for x in initial:
            if vis[x]:
                continue
            node_id = -1
            size = 0
            dfs(x)
            if node_id >= 0 and (size > max_size or size == max_size and node_id < ans):
                ans = node_id
                max_size = size
        return min(initial) if ans < 0 else ans